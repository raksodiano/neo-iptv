import json

from .connection import create_connection
from ...config.logger import logger

# Global variable for database path
DATABASE_PATH = "iptv.db"


class Channel:
    def __init__(self, id, name, url, duration, attributes=None, extras=None):
        """
        Simplified constructor that only handles the necessary fields:
        - id (int): Unique identifier for the channel (automatically generated by the database).
        - name (str): Name of the channel.
        - url (str): URL of the channel (e.g., .m3u8 format).
        - duration (str): Duration of the channel (e.g., "-1").
        - attributes (dict): Additional attributes in dictionary format.
        - extras (list): List of additional options (e.g., specific VLC settings).
        """
        self.id = id
        self.name = name
        self.url = url
        self.duration = duration
        self.attributes = attributes or {}
        self.extras = extras or []

    def __repr__(self):
        return f"<Channel(id={self.id}, name={self.name}, url={self.url}, attributes={self.attributes}, extras={self.extras})>"

    def to_dict(self):
        """ Converts the channel to a dictionary in the required JSON format. """
        return {
            "name": self.name,
            "duration": str(self.duration),
            "url": self.url,
            "attributes": self.attributes,
            "extras": self.extras
        }

    @staticmethod
    def _execute_query(query, params=(), fetch=False):
        """ Helper method to manage database connections and execute queries. """
        with create_connection(DATABASE_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            if fetch:
                return cursor.fetchall()
            conn.commit()

    @staticmethod
    def create_table():
        """ Creates the channels table in the database if it doesn't exist. """
        sql_query = """
            CREATE TABLE IF NOT EXISTS channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                url TEXT NOT NULL,
                duration TEXT,
                attributes TEXT,
                extras TEXT,
                tuned BOOLEAN DEFAULT 1,
                favorite BOOLEAN DEFAULT 0,
                last BOOLEAN DEFAULT 0
            )
        """
        Channel._execute_query(sql_query)

    @staticmethod
    def insert_channel(channel_data):
        """
        Inserts a new channel into the database using dynamic columns based on the provided object.
        """
        if isinstance(channel_data, dict):
            fields = channel_data
        elif hasattr(channel_data, '__dict__'):
            fields = vars(channel_data)
        else:
            raise TypeError("Provided data must be either a dictionary or an object with attributes.")

        filtered_fields = {k: v for k, v in fields.items() if v is not None}
        Channel._serialize_json_fields(filtered_fields)

        columns = ', '.join(filtered_fields.keys())
        placeholders = ', '.join(['?'] * len(filtered_fields))
        values = tuple(filtered_fields.values())

        sql_query = f"INSERT INTO channels ({columns}) VALUES ({placeholders})"
        Channel._execute_query(sql_query, values)

    @staticmethod
    def _serialize_json_fields(fields):
        """ Serializes 'attributes' and 'extras' fields if they are in the provided dictionary. """
        for key in ['attributes', 'extras']:
            if key in fields and isinstance(fields[key], (dict, list)):
                fields[key] = json.dumps(fields[key])

    @staticmethod
    def _deserialize_json_fields(row):
        """ Deserializes 'attributes' and 'extras' fields from JSON strings. """
        return Channel(
            id=row[0],
            name=row[1],
            url=row[2],
            duration=row[3],
            attributes=json.loads(row[4]) if row[4] else {},
            extras=json.loads(row[5]) if row[5] else []
        )

    @staticmethod
    def get_all_channels():
        """ Retrieves all channels from the database that are marked as 'tuned' (tuned = 1). """
        sql_query = "SELECT * FROM channels WHERE tuned = 1 ORDER BY name ASC"
        rows = Channel._execute_query(sql_query, fetch=True)

        return [Channel._deserialize_json_fields(row) for row in rows]

    @staticmethod
    def get_all_channels_without_filters():
        """ Retrieves all channels from the database. """
        sql_query = "SELECT * FROM channels"
        rows = Channel._execute_query(sql_query, fetch=True)

        return [Channel._deserialize_json_fields(row) for row in rows]

    @staticmethod
    def get_channel_by_id(channel_id):
        """ Retrieves a channel by its ID. """
        sql_query = "SELECT * FROM channels WHERE id=?"
        row = Channel._execute_query(sql_query, (channel_id,), fetch=True)

        if row:
            return Channel._deserialize_json_fields(row[0])
        return None

    @staticmethod
    def get_channel_by_url(channel_url):
        """ Retrieves a channel by its URL. """
        sql_query = "SELECT * FROM channels WHERE url=?"
        row = Channel._execute_query(sql_query, (channel_url,), fetch=True)

        if row:
            return Channel._deserialize_json_fields(row[0])
        return None

    @staticmethod
    def update_channel(channel_id, update_data):
        """ Updates a channel in the database with new values. """
        if not isinstance(update_data, dict) or not update_data:
            logger.error("Error: The update_data parameter must be a non-empty dictionary.")
            return

        set_clause = ", ".join([f"{field} = ?" for field in update_data])
        values = list(update_data.values()) + [channel_id]

        sql_query = f"UPDATE channels SET {set_clause} WHERE id = ?"
        Channel._execute_query(sql_query, tuple(values))

    @staticmethod
    def delete_channel(channel_id):
        """ Deletes a channel from the database by its ID. """
        sql_query = "DELETE FROM channels WHERE id=?"
        Channel._execute_query(sql_query, (channel_id,))
