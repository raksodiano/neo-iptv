import json
from .connection import create_connection, close_connection


class Channel:
    def __init__(self, id, name, url, duration, attributes=None, extras=None):
        """
        Simplified constructor that only handles the necessary fields:
        - id (int): Unique identifier for the channel (automatically generated by the database).
        - name (str): Name of the channel.
        - url (str): URL of the channel (e.g., .m3u8 format).
        - duration (str): Duration of the channel (e.g., "-1").
        - attributes (dict): Additional attributes in dictionary format.
        - extras (list): List of additional options (e.g., specific VLC settings).
        """
        self.id = id
        self.name = name
        self.url = url
        self.duration = duration
        self.attributes = attributes or {}
        self.extras = extras or []

    def __repr__(self):
        return f"<Channel(name={self.name}, url={self.url})>"

    def to_dict(self):
        """ Converts the channel to a dictionary in the required JSON format. """
        return {
            "name": self.name,
            "duration": str(self.duration),
            "url": self.url,
            "attributes": self.attributes,
            "extras": self.extras
        }

    @staticmethod
    def create_table():
        """ Creates the channels table in the database if it doesn't exist. """
        conn = create_connection("iptv.db")
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                url TEXT NOT NULL,
                duration TEXT,
                attributes TEXT,
                extras TEXT,
                tuned BOOLEAN DEFAULT 1,
                favorite BOOLEAN DEFAULT 0,
                last BOOLEAN DEFAULT 0
            )
        """)
        conn.commit()
        close_connection(conn)

    @staticmethod
    def insert_channel(channel_data):
        """Inserts a new channel into the database using dynamic columns based on the provided object (dictionary or class)."""
        if isinstance(channel_data, dict):
            fields = channel_data
        elif hasattr(channel_data, '__dict__'):
            fields = vars(channel_data)
        else:
            raise TypeError("Provided data must be either a dictionary or an object with attributes.")

        filtered_fields = {k: v for k, v in fields.items() if v is not None}

        if 'attributes' in filtered_fields and isinstance(filtered_fields['attributes'], (dict, list)):
            filtered_fields['attributes'] = json.dumps(filtered_fields['attributes'])
        if 'extras' in filtered_fields and isinstance(filtered_fields['extras'], (dict, list)):
            filtered_fields['extras'] = json.dumps(filtered_fields['extras'])

        columns = ', '.join(filtered_fields.keys())
        placeholders = ', '.join(['?'] * len(filtered_fields))
        values = tuple(filtered_fields.values())

        sql_query = f"""
            INSERT INTO channels ({columns})
            VALUES ({placeholders})
        """

        conn = create_connection("iptv.db")
        cursor = conn.cursor()

        cursor.execute(sql_query, values)
        conn.commit()
        close_connection(conn)

    @staticmethod
    def get_all_channels():
        """ Retrieves all channels from the database that are marked as 'tuned' (tuned = 1). """
        conn = create_connection("iptv.db")
        cursor = conn.cursor()

        cursor.execute("SELECT * FROM channels WHERE tuned = 1")
        rows = cursor.fetchall()

        conn.close()

        return [
            Channel(
                id=row[0],
                name=row[1],
                url=row[2],
                duration=row[3],
                attributes=json.loads(row[4]) if row[4] else {},  # attributes
                extras=json.loads(row[5]) if row[5] else []  # extras
            )
            for row in rows
        ]

    @staticmethod
    def get_all_channels_without_filters():
        """ Retrieves all channels from the database. """
        conn = create_connection("iptv.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM channels")
        rows = cursor.fetchall()
        close_connection(conn)

        # Convert the results to Channel objects and deserialize attributes and extras.
        return [
            Channel(
                id=row[0],  # id
                name=row[1],  # name
                url=row[2],  # url
                duration=row[3],  # duration
                attributes=json.loads(row[4]) if row[4] else {},  # attributes
                extras=json.loads(row[5]) if row[5] else []  # extras
            )
            for row in rows
        ]

    @staticmethod
    def get_channel_by_id(channel_id):
        """ Retrieves a channel by its ID. """
        conn = create_connection("iptv.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM channels WHERE id=?", (channel_id,))
        row = cursor.fetchone()
        close_connection(conn)

        if row:
            return Channel(
                id=row[0],  # id
                name=row[1],  # name
                url=row[2],  # url
                duration=row[3],  # duration
                attributes=json.loads(row[4]) if row[4] else {},  # attributes
                extras=json.loads(row[5]) if row[5] else []  # extras
            )
        return None

    @staticmethod
    def get_channel_by_url(channel_url):
        """ Retrieves a channel by its URL. """
        conn = create_connection("iptv.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM channels WHERE url=?", (channel_url,))
        row = cursor.fetchone()
        close_connection(conn)

        if row:
            return Channel(
                id=row[0],  # id
                name=row[1],  # name
                url=row[2],  # url
                duration=row[3],  # duration
                attributes=json.loads(row[4]) if row[4] else {},  # attributes
                extras=json.loads(row[5]) if row[5] else []  # extras
            )
        return None

    @staticmethod
    def update_channel(channel_id, update_data):
        """ Updates a channel in the database with new values. """
        if not isinstance(update_data, dict):
            print("Error: The update_data parameter must be a dictionary.")
            return

        if not update_data:
            print("No fields to update.")
            return

        # Create the UPDATE query
        set_clause = ", ".join([f"{field} = ?" for field in update_data])
        values = list(update_data.values()) + [channel_id]

        conn = create_connection("iptv.db")
        cursor = conn.cursor()

        # Execute the UPDATE query
        cursor.execute(f"UPDATE channels SET {set_clause} WHERE id = ?", tuple(values))
        conn.commit()
        close_connection(conn)

    @staticmethod
    def delete_channel(channel_id):
        """ Deletes a channel from the database by its ID. """
        conn = create_connection("iptv.db")
        cursor = conn.cursor()
        cursor.execute("DELETE FROM channels WHERE id=?", (channel_id,))
        conn.commit()
        close_connection(conn)
        print(f"Channel with ID {channel_id} deleted successfully.")
